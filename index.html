<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rabbit Runner</title>
  <style>
    /* Basic reset and styling for full-screen canvas and UI elements */
    body { margin: 0; overflow: hidden; font-family: sans-serif; background: #444; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 24px;
      z-index: 100;
    }
    #ouch {
      position: absolute;
      color: red;
      font-size: 32px;
      font-weight: bold;
      z-index: 100;
      display: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="ouch">OUCH!</div>
  
  <!-- Three.js library from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Global variables for scene, camera, and game state.
    let scene, camera, renderer, clock;
    let rabbit, rabbitMoveX = 0;
    let objects = []; // Holds both collectibles and obstacles
    let score = 0;
    let spawnTimer = 0;
    let touchX = null;
    const scoreDiv = document.getElementById('score');
    const ouchDiv = document.getElementById('ouch');

    // Initialize the Three.js scene and game objects.
    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);
      
      // Set up the camera with perspective projection.
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);
      
      // Create the WebGL renderer.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      clock = new THREE.Clock();

      // Lighting for a more immersive 3D look.
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);
      
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(-3, 10, -10);
      scene.add(dirLight);

      // Create a large ground plane.
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = - Math.PI / 2;
      scene.add(ground);

      // Create the rabbit character.
      rabbit = createRabbit();
      rabbit.position.set(0, 0, 0);
      scene.add(rabbit);

      // Handle window resizing.
      window.addEventListener('resize', onWindowResize, false);
      // Set up touch events for finger control.
      window.addEventListener('touchstart', onTouchStart, false);
      window.addEventListener('touchmove', onTouchMove, false);
    }

    // Create a simple rabbit model using basic geometries.
    function createRabbit() {
      const rabbitGroup = new THREE.Group();

      // Body: a white sphere.
      const bodyGeom = new THREE.SphereGeometry(0.5, 16, 16);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.position.y = 0.5;
      rabbitGroup.add(body);

      // Ears: two cylinders.
      const earGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
      const earMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const leftEar = new THREE.Mesh(earGeom, earMat);
      leftEar.position.set(-0.2, 1.3, 0);
      leftEar.rotation.z = 0.2;
      rabbitGroup.add(leftEar);
      const rightEar = new THREE.Mesh(earGeom, earMat);
      rightEar.position.set(0.2, 1.3, 0);
      rightEar.rotation.z = -0.2;
      rabbitGroup.add(rightEar);

      return rabbitGroup;
    }

    // Update the renderer and camera aspect when the window resizes.
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Handle the start of a touch event.
    function onTouchStart(event) {
      touchX = event.touches[0].clientX;
    }

    // Handle finger movement to steer the rabbit horizontally.
    function onTouchMove(event) {
      if (touchX !== null) {
        const deltaX = event.touches[0].clientX - touchX;
        // Adjust sensitivity of horizontal movement.
        rabbitMoveX = deltaX * 0.01;
      }
    }

    // Spawn either a collectible (fruit or vegetable) or an obstacle (tree or rock).
    function spawnObject() {
      const isCollectible = Math.random() < 0.6; // 60% chance collectible
      let obj, geometry, material;

      // Random horizontal position within a defined range.
      const xPos = (Math.random() - 0.5) * 6; // approximately between -3 and 3
      const zPos = -50; // Spawn far ahead in the scene
      const yPos = 0.5;

      if (isCollectible) {
        // Randomly choose between fruit and vegetable.
        const isFruit = Math.random() < 0.5;
        if (isFruit) {
          // Fruit represented as a red sphere.
          geometry = new THREE.SphereGeometry(0.3, 8, 8);
          material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        } else {
          // Vegetable represented as a green box.
          geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
          material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        }
        obj = new THREE.Mesh(geometry, material);
        obj.userData = { type: 'collectible' };
      } else {
        // Spawn an obstacle: either a tree or a rock.
        const isTree = Math.random() < 0.5;
        if (isTree) {
          // Tree: combine a trunk and a leafy top.
          const trunkGeom = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
          const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
          const trunk = new THREE.Mesh(trunkGeom, trunkMat);
          trunk.position.y = 0.5;
          const leavesGeom = new THREE.ConeGeometry(0.5, 1, 8);
          const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
          const leaves = new THREE.Mesh(leavesGeom, leavesMat);
          leaves.position.y = 1.3;
          obj = new THREE.Group();
          obj.add(trunk);
          obj.add(leaves);
        } else {
          // Rock: a simple gray sphere.
          geometry = new THREE.SphereGeometry(0.4, 8, 8);
          material = new THREE.MeshStandardMaterial({ color: 0x808080 });
          obj = new THREE.Mesh(geometry, material);
        }
        obj.userData = { type: 'obstacle' };
      }
      obj.position.set(xPos, yPos, zPos);
      scene.add(obj);
      objects.push(obj);
    }

    // Simple collision detection using distance in the horizontal (x-z) plane.
    function checkCollision(obj) {
      const rabbitPos = new THREE.Vector3();
      rabbit.getWorldPosition(rabbitPos);
      const objPos = obj.position.clone();
      const dx = rabbitPos.x - objPos.x;
      const dz = rabbitPos.z - objPos.z;
      const distance = Math.sqrt(dx * dx + dz * dz);
      return distance < 0.7; // collision threshold
    }

    // Display the word "OUCH" briefly near the rabbit when hitting an obstacle.
    function showOuch() {
      // Project the rabbit's 3D position to 2D screen coordinates.
      const vector = new THREE.Vector3();
      rabbit.getWorldPosition(vector);
      vector.project(camera);
      const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
      ouchDiv.style.left = (x - 20) + 'px';
      ouchDiv.style.top = (y - 50) + 'px';
      ouchDiv.style.display = 'block';
      setTimeout(() => {
        ouchDiv.style.display = 'none';
      }, 500); // Display for 0.5 seconds
    }

    // Main game loop: update positions, check collisions, spawn new objects, and render.
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Update rabbit's horizontal position from touch input.
      rabbit.position.x += rabbitMoveX;
      // Keep the rabbit within horizontal bounds.
      rabbit.position.x = Math.max(Math.min(rabbit.position.x, 3), -3);
      // Gradually reduce the movement delta for smooth control.
      rabbitMoveX *= 0.9;

      // Move each spawned object toward the camera.
      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        obj.position.z += 10 * delta; // Move speed
        if (checkCollision(obj)) {
          if (obj.userData.type === 'collectible') {
            score += 10;
          } else if (obj.userData.type === 'obstacle') {
            score = Math.max(score - 5, 0);
            showOuch();
          }
          scoreDiv.innerHTML = 'Score: ' + score;
          scene.remove(obj);
          objects.splice(i, 1);
        } else if (obj.position.z > camera.position.z + 5) {
          // Remove objects that have passed the camera.
          scene.remove(obj);
          objects.splice(i, 1);
        }
      }

      // Spawn new objects periodically.
      spawnTimer += delta;
      if (spawnTimer > 0.8) { // roughly every 0.8 seconds
        spawnObject();
        spawnTimer = 0;
      }

      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
